[{"uri":"https://squoc.github.io/","title":"Home Page","tags":[],"description":"","content":"Gitops and ArgoCD Documentation Website where gitops model and argoCD are documented for future reference. Everyone is welcome to contribute.\nFor a better Bosch devops community!\n"},{"uri":"https://squoc.github.io/gitops-secret-manager/hashicorp-vault/","title":"Hashicorp Vault","tags":[],"description":"","content":"Vault, by HashiCorp, is a purpose built, open source tool for storing and managing Secrets in a secure manner.\nInstallation and Setup Helm chart The easiest way to install Vault is using the official Helm chart maintained by HashiCorp.\nhelm repo add hashicorp https://helm.releases.hashicorp.com helm install vault hashicorp/vault \\ --set server.dev.enabled=true \\ Vault CLI We can download and install Vault CLI from the official website\nOnce installed, Vault can be accessed through standard port forwarding, and visiting the UI at http://localhost:8200\nUsage Once Vault is installed in your cluster, it’s time to store your first Secret in Vault:\nvault kv put secret/hello foo=world Retrieve secret:\nvault kv get secret/hello Vault Agent Sidecar injector For an application to retrieve Secrets from Vault, we need to perform some prerequisite steps before launching the application. We need a security token to access secrets in k8s. That would take us back to chicken-and-egg problem. To solve this problem, HashiCorp developed the Vault Agent Sidecar Injector.\nHow it works The Vault Agent Sidecar Injector automatically modifies Pods that are annotated a specific way, and securely retrieves annotated Secret references (application Secrets) and renders those values into a shared volume accessible to the application container.\nInstallation We pass an additional argument injector.enabled=true to helm chart installation:\nhelm install vault hashicorp/vault \\ --set server.dev.enabled=true \\ --set injector.enabled=true Usage When an application desires to retrieve its Secrets from Vault, the Pod spec needs to have at a minimum the following Vault agent annotations. annotations:\nvault.hashicorp.com/agent-inject: \u0026#34;true\u0026#34; vault.hashicorp.com/agent-inject-secret-hello.txt: secret/hello vault.hashicorp.com/role: app These annotations convey several pieces of information:\nThe annotation key vault.hashicorp.com/agent-inject: \u0026ldquo;true\u0026rdquo; informs the Vault Agent Sidecar Injector that Vault Secret injection should occur for this Pod. The annotation value secret/hello indicates which Vault Secret key to inject into the Pod. The suffix hello.txt of the annotation, vault.hashicorp.com/agentinject-secret-hello.txt, indicates that the Secret should be populated under a file named hello.txt in the shared memory volume with the final path being /vault/secrets/hello.txt. The annotation value from the vault.hashicorp.com/role indicates which Vault role should be used when retrieving the Secret. Configuration the sidecar injector access to secrets We need to configure Vault to allow Kubernetes Pods to authenticate and retrieve Secrets. To do so, run the following Vault commands to enable the Kubernetes auth method:\nvault auth enable kubernetes Success! Enabled kubernetes auth method at: kubernetes/ vault write auth/kubernetes/config \\ token_reviewer_jwt=\u0026#34;$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\u0026#34; \\ kubernetes_host=\u0026#34;https://$KUBERNETES_PORT_443_TCP_ADDR:443\u0026#34; \\ kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt Success! Data written to: auth/kubernetes/config These two commands configure Vault to use the Kubernetes authentication method to use the service account token, the location of the Kubernetes host, and its certificate.\nNext, we define a policy named “app,” as well as a role named “app,” which will have read privileges to the “hello” Secret:\n# Create a policy \u0026#34;app\u0026#34; which will have read privileges to the \u0026#34;secret/hello\u0026#34; secret $ vault policy write app - \u0026lt;\u0026lt;EOF path \u0026#34;secret/hello\u0026#34; { capabilities = [\u0026#34;read\u0026#34;] } EOF # Grants a pod in the \u0026#34;default\u0026#34; namespace using the \u0026#34;default\u0026#34; service account # privileges to read the \u0026#34;hello\u0026#34; secret $ vault write auth/kubernetes/role/app \\ bound_service_account_names=default \\ bound_service_account_namespaces=default \\ policies=app \\ ttl=24h "},{"uri":"https://squoc.github.io/gitops-tools/argocd/","title":"ArgoCD","tags":[],"description":"","content":"One of the most popular tools to deploy resources to k8s cluster.\nArgoCD Application Dependencies App of Apps pattern The App of Apps pattern design is basically an Argo CD application made up of other argoCD applications. The purpose is to bootstrapping our application and its dependencies. Administrators need a way to deploy argoCD applications using argoCD itself. The solution is to create an application made up of other argoCD applications.\nFor example, we have an application that has dependencies on:\nCert-Manager Backend Application Ingress Frontend Application etc\u0026hellip; Instead of deploying a bunch of argoCD applications individually, we could deploy one argoCD application that deploys other application.\nThis is very convenient because it provides an entry point and bootstraps dependencies before the main application goes online.\nSyncWaves and Resource Hooks SyncWaves and resource hooks are a way we can order how argoCD applies individual manifests to allocation resources on k8s cluster. We use annotation (not labels) to annotate the object with the order we\u0026rsquo;d like to apply the manifest, number based with lowest going first. For example, we have a Deployment numbered as 0 and a Service as 1, argoCD will apply the Deployment first, waiting for it to report healthy, then apply the Service\ntest 2 test 3 test 4 "},{"uri":"https://squoc.github.io/getting-started/what-is-gitops/","title":"What Is Gitops?","tags":[],"description":"","content":"What is GitOps? GitOps is a set of best practices for declaratively observing and describing a system’s operating infrastructure. You can apply the GitOps methodology throughout the application development workflow, using Git as a single source of truth to actively reconcile and declaratively configure an application.\nIn a GitOps model, the system’s desired configuration is stored in a revision con- trol system, such as Git. Instead of making changes directly to the system via a UI or CLI, an engineer makes changes to the configuration files that represent the desired state. A difference between the desired state stored in Git and the system’s actual state indicates that not all changes have been deployed. These changes can be reviewed and approved through standard revision control processes such as pull requests, code reviews, and merges to master.\nWhen changes have been approved and merged to the main branch, an operator software process is responsible for changing the system’s current state to the desired state based on the configuration stored in Git.\nGitOps doesn’t require a particular set of tools, but the tools must offer this stan- dard functionality:\nOperate on the desired state of the system that is stored in Git Detect differences between the desired state and the actual state Perform the required operations on the infrastructure to synchronize the actual state with the desired state Although this book focuses on GitOps in relation to Kubernetes, many of the princi- ples of GitOps could be implemented independently of Kubernetes. "},{"uri":"https://squoc.github.io/getting-started/","title":"Getting Started","tags":[],"description":"","content":"1. Getting Started GitOps model in Devops\n"},{"uri":"https://squoc.github.io/getting-started/benefits-of-gitops/","title":"Benefits of Gitops","tags":[],"description":"","content":"Benefits of GitOps Combining a GitOps methodology with Kubernetes’ declarative configuration and active reconciliation model provides many operational benefits that provide a more predictable and reliable system.\nDeclarative In an imperative model, we specify a series of steps to instruct the system how to reach our desired state. In contrast, with declarative models, we describe what we want to achieve as opposed to how to get there.\nGitOps model solely uses declarative manifests stored in Git repo that declare the desired state and let a gitops tool to detect and converge with kubernetes cluster.\nDisaster recovery GitOps helps in the recovery of infrastructure environments by storing declarative specifications of the environment under source control as a source of truth. Having a complete definition of what the environment should be facilitates the re-creation of the environment in the event of a disaster. Disaster recovery becomes a simple exer- cise of (re)applying all the configuration stored in the Git repository.\nObservability Observability mechanisms can help answer the question, “What’s cur- rently running in my environment?”\nDeployed environments are expected to be observable. In other words, you should always be able to inspect an environment to see what is currently running and how things are configured. If the environment’s running state can be observed, and the desired state of the environment is detect divergence from the defined in Git, the environment can be verified by desired state.\n"},{"uri":"https://squoc.github.io/gitops-tools/flux/","title":"Flux","tags":[],"description":"","content":"To Be Continued\u0026hellip;\n"},{"uri":"https://squoc.github.io/gitops-tools/","title":"Gitops Tools","tags":[],"description":"","content":"2. GitOps Tools Introducing some of the most popular gitops tools\n"},{"uri":"https://squoc.github.io/gitops-secret-manager/kustomize-secret-generator-plugin/","title":"Kustomize Secret Generator Plugin","tags":[],"description":"","content":"To be continued\u0026hellip;\n"},{"uri":"https://squoc.github.io/gitops-secret-manager/","title":"Gitops Secret Management","tags":[],"description":"","content":"Chapter 3 Secret Management for ArgoCD base64 encoding is not encryption. Secrets in k8s is not encrypted but encoded. This is why we need to implement some other methods to encrypt secrets.\n"},{"uri":"https://squoc.github.io/gitops-tools/jenkinsx/","title":"JenkinsX","tags":[],"description":"","content":"To Be Continued\u0026hellip;\n"},{"uri":"https://squoc.github.io/gitops-secret-manager/sealed-secret/","title":"Sealed Secret","tags":[],"description":"","content":"To be continued\u0026hellip;\n"},{"uri":"https://squoc.github.io/getting-started/test/","title":"Test","tags":[],"description":"","content":"this is a block of code\nconsole.log(\u0026#39;hello world\u0026#39;); "},{"uri":"https://squoc.github.io/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://squoc.github.io/tags/","title":"Tags","tags":[],"description":"","content":""}]