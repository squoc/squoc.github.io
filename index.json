[{"uri":"https://squoc.github.io/","title":"Home Page","tags":[],"description":"","content":"Gitops and ArgoCD Documentation Website where gitops model and argoCD are documented for future reference. Everyone is welcome to contribute.\nFor a better Bosch devops community!\n"},{"uri":"https://squoc.github.io/gitops-tools/argocd/","title":"ArgoCD","tags":[],"description":"","content":"One of the most popular tools to deploy resources to k8s cluster.\nArgoCD Application Dependencies App of Apps pattern The App of Apps pattern design is basically an Argo CD application made up of other argoCD applications. The purpose is to bootstrapping our application and its dependencies. Administrators need a way to deploy argoCD applications using argoCD itself. The solution is to create an application made up of other argoCD applications.\nFor example, we have an application that has dependencies on:\nCert-Manager Backend Application Ingress Frontend Application etc\u0026hellip; Instead of deploying a bunch of argoCD applications individually, we could deploy one argoCD application that deploys other application.\nThis is very convenient because it provides an entry point and bootstraps dependencies before the main application goes online.\nSyncWaves and Resource Hooks SyncWaves and resource hooks are a way we can order how argoCD applies individual manifests to allocation resources on k8s cluster. We use annotation (not labels) to annotate the object with the order we\u0026rsquo;d like to apply the manifest, number based with lowest going first. For example, we have a Deployment numbered as 0 and a Service as 1, argoCD will apply the Deployment first, waiting for it to report healthy, then apply the Service\ntest 2 test 3 test 4 "},{"uri":"https://squoc.github.io/getting-started/what-is-gitops/","title":"What Is Gitops?","tags":[],"description":"","content":"What is GitOps? GitOps is a set of best practices for declaratively observing and describing a system’s operating infrastructure. You can apply the GitOps methodology throughout the application development workflow, using Git as a single source of truth to actively reconcile and declaratively configure an application.\nIn a GitOps model, the system’s desired configuration is stored in a revision con- trol system, such as Git. Instead of making changes directly to the system via a UI or CLI, an engineer makes changes to the configuration files that represent the desired state. A difference between the desired state stored in Git and the system’s actual state indicates that not all changes have been deployed. These changes can be reviewed and approved through standard revision control processes such as pull requests, code reviews, and merges to master.\nWhen changes have been approved and merged to the main branch, an operator software process is responsible for changing the system’s current state to the desired state based on the configuration stored in Git.\nGitOps doesn’t require a particular set of tools, but the tools must offer this stan- dard functionality:\nOperate on the desired state of the system that is stored in Git Detect differences between the desired state and the actual state Perform the required operations on the infrastructure to synchronize the actual state with the desired state Although this book focuses on GitOps in relation to Kubernetes, many of the princi- ples of GitOps could be implemented independently of Kubernetes. "},{"uri":"https://squoc.github.io/getting-started/","title":"Getting Started","tags":[],"description":"","content":"1. Getting Started GitOps model in Devops\n"},{"uri":"https://squoc.github.io/getting-started/benefits-of-gitops/","title":"Benefits of Gitops","tags":[],"description":"","content":"Benefits of GitOps Combining a GitOps methodology with Kubernetes’ declarative configuration and active reconciliation model provides many operational benefits that provide a more predictable and reliable system.\nDeclarative In an imperative model, we specify a series of steps to instruct the system how to reach our desired state. In contrast, with declarative models, we describe what we want to achieve as opposed to how to get there.\nGitOps model solely uses declarative manifests stored in Git repo that declare the desired state and let a gitops tool to detect and converge with kubernetes cluster.\nDisaster recovery GitOps helps in the recovery of infrastructure environments by storing declarative specifications of the environment under source control as a source of truth. Having a complete definition of what the environment should be facilitates the re-creation of the environment in the event of a disaster. Disaster recovery becomes a simple exer- cise of (re)applying all the configuration stored in the Git repository.\nObservability Observability mechanisms can help answer the question, “What’s cur- rently running in my environment?”\nDeployed environments are expected to be observable. In other words, you should always be able to inspect an environment to see what is currently running and how things are configured. If the environment’s running state can be observed, and the desired state of the environment is detect divergence from the defined in Git, the environment can be verified by desired state.\n"},{"uri":"https://squoc.github.io/gitops-tools/flux/","title":"Flux","tags":[],"description":"","content":"To Be Continued\u0026hellip;\n"},{"uri":"https://squoc.github.io/gitops-tools/","title":"Gitops Tools","tags":[],"description":"","content":"2. GitOps Tools Introducing some of the most popular gitops tools\n"},{"uri":"https://squoc.github.io/gitops-tools/jenkinsx/","title":"JenkinsX","tags":[],"description":"","content":"To Be Continued\u0026hellip;\n"},{"uri":"https://squoc.github.io/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://squoc.github.io/tags/","title":"Tags","tags":[],"description":"","content":""}]